//-----------------------------------------------------------------------------
// File : asfBit.h
// Desc : Bit Operations.
// Copyright(c) Project Asura. All right reserved.
//-----------------------------------------------------------------------------
#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <cassert>
#include <cstdint>

#if _HAS_CXX20
#include <bit>      // for std::bit_cast().
#else
#include <cstring>  // form memcpy().
#endif


namespace asf {

//-----------------------------------------------------------------------------
//! @brief      立っているビットを数えます.
//! 
//! @return     立っているビットの数を返却します.
//! @note       popcount() と同じ挙動です.
//-----------------------------------------------------------------------------
int CountBit(uint8_t  value);
int CountBit(uint16_t value);
int CountBit(uint32_t value);
int CountBit(uint64_t value);

//-----------------------------------------------------------------------------
//! @brief      左端から連続した0となるビットの数を数えます.
//! 
//! @param[in]      value       数える数値.
//! @return     左端から連続した0となるビットの数を返却します.
//! @note       左端が0でない場合は常にゼロとなります. clz() と同じ挙動です.
//-----------------------------------------------------------------------------
int CountZeroL(uint8_t  value);
int CountZeroL(uint16_t value);
int CountZeroL(uint32_t value);
int CountZeroL(uint64_t value);

//-----------------------------------------------------------------------------
//! @brief      右端から連続した0となるビットの数を数えます.
//! 
//! @param[in]      value       数える数値.
//! @return     右端から連続した0となるビットの数を返却します.
//! @note       右端が0でない場合は常にゼロとなります. ctz() と同じ挙動です.
//-----------------------------------------------------------------------------
int CountZeroR(uint8_t  value);
int CountZeroR(uint16_t value);
int CountZeroR(uint32_t value);
int CountZeroR(uint64_t value);

//-----------------------------------------------------------------------------
//! @brief      左端から連続した1となるビットの数を数えます.
//! 
//! @param[in]      value       数える数値.
//! @return     左端から連続した1となるビットの数を返却します.
//! @note       左端が1でない場合は常にゼロとなります.
//-----------------------------------------------------------------------------
inline int CountOneL(uint8_t  value) { return CountZeroL(uint8_t(~value)); }
inline int CountOneL(uint16_t value) { return CountZeroL(uint16_t(~value)); }
inline int CountOneL(uint32_t value) { return CountZeroL(uint32_t(~value)); }
inline int CountOneL(uint64_t value) { return CountZeroL(uint64_t(~value)); }

//-----------------------------------------------------------------------------
//! @brief      右端から連続した1となるビットの数を数えます.
//! 
//! @param[in]      value       数える数値.
//! @return     右端から連続した1となるビットの数を返却します.
//! @note       右端が1でない場合は常にゼロとなります.
//-----------------------------------------------------------------------------
inline int CountOneR(uint8_t  value) { return CountZeroR(uint8_t(~value)); }
inline int CountOneR(uint16_t value) { return CountZeroR(uint16_t(~value)); }
inline int CountOneR(uint32_t value) { return CountZeroR(uint32_t(~value)); }
inline int CountOneR(uint64_t value) { return CountZeroR(uint64_t(~value)); }

//-----------------------------------------------------------------------------
//! @brief      左から探索し，最初に0となるビットの番号を求めます.
//! 
//! @param[in]      value       数える数値.
//! @return     左から探索し，最初に0となるビットの番号を返却します.
//-----------------------------------------------------------------------------
inline int FindZeroL(uint8_t  value) { return value == uint8_t (~0) ? 0 :  8 - CountOneL(value); }
inline int FindZeroL(uint16_t value) { return value == uint16_t(~0) ? 0 : 16 - CountOneL(value); }
inline int FindZeroL(uint32_t value) { return value == uint32_t(~0) ? 0 : 32 - CountOneL(value); }
inline int FindZeroL(uint64_t value) { return value == uint64_t(~0) ? 0 : 64 - CountOneL(value); }

//-----------------------------------------------------------------------------
//! @brief      右から探索し，最初に0となるビットの番号を求めます.
//! 
//! @param[in]      value       数える数値.
//! @return     右から探索し，最初に0となるビットの番号を返却します.
//-----------------------------------------------------------------------------
inline int FindZeroR(uint8_t  value) { return value == uint8_t (~0) ? 0 : CountOneR(value) + 1; }
inline int FindZeroR(uint16_t value) { return value == uint16_t(~0) ? 0 : CountOneR(value) + 1; }
inline int FindZeroR(uint32_t value) { return value == uint32_t(~0) ? 0 : CountOneR(value) + 1; }
inline int FindZeroR(uint64_t value) { return value == uint64_t(~0) ? 0 : CountOneR(value) + 1; }

//-----------------------------------------------------------------------------
//! @brief      左から探索し，最初に1となるビットの番号を求めます.
//! 
//! @param[in]      value       数える数値.
//! @return     左から探索し，最初に1となるビットの番号を返却します.
//-----------------------------------------------------------------------------
inline int FindOneL(uint8_t  value) { return value == 0 ? 0 :  8 - CountZeroL(value); }
inline int FindOneL(uint16_t value) { return value == 0 ? 0 : 16 - CountZeroL(value); }
inline int FindOneL(uint32_t value) { return value == 0 ? 0 : 32 - CountZeroL(value); }
inline int FindOneL(uint64_t value) { return value == 0 ? 0 : 64 - CountZeroL(value); }

//-----------------------------------------------------------------------------
//! @brief      右から探索し，最初に1となるビットの番号を求めます.
//! 
//! @param[in]      value       数える数値.
//! @return     右から探索し，最初に1となるビットの番号を返却します.
//-----------------------------------------------------------------------------
inline int FindOneR(uint8_t  value) { return value == 0 ? 0 : CountZeroR(value) + 1; }
inline int FindOneR(uint16_t value) { return value == 0 ? 0 : CountZeroR(value) + 1; }
inline int FindOneR(uint32_t value) { return value == 0 ? 0 : CountZeroR(value) + 1; }
inline int FindOneR(uint64_t value) { return value == 0 ? 0 : CountZeroR(value) + 1; }


#if _HAS_CXX20
//-----------------------------------------------------------------------------
//! @brief      ビット列を崩さずに型キャストします.
//-----------------------------------------------------------------------------
template<typename To, typename From>
inline To bit_cast(const From& value)
{ return std::bit_cast<To>(value); }

#else
//-----------------------------------------------------------------------------
//! @brief      ビット列を崩さずに型キャストします.
//-----------------------------------------------------------------------------
template<typename To, typename From>
inline To bit_cast(const From& value)
{
    // データサイズが一致することを確認.
    static_assert(sizeof(To) == sizeof(From), "bit_cast() size not matched.");

    To ret = {};
    memcpy(&ret, &value, sizeof(ret));
    return ret;
}
#endif

//-----------------------------------------------------------------------------
//! @brief      ビットフィールドを抽出します.
//-----------------------------------------------------------------------------
inline uint32_t BitFieldExtract(uint32_t src, uint32_t offset, uint32_t bits)
{
    uint32_t mask = (1u << bits) - 1u;
    return (src >> offset) & mask;
}

//-----------------------------------------------------------------------------
//! @brief      ビットフィールドを抽出します.
//-----------------------------------------------------------------------------
inline int BitFieldExtractSigned(int src, uint32_t offset, uint32_t bits)
{
    int shifted = src >> offset;
    int signBit = shifted & (1u << (bits - 1u));
    uint32_t mask = (1u << bits) - 1u;
    return ~signBit | (shifted & mask);
}

//-----------------------------------------------------------------------------
//! @brief      ビットフィールドを挿入します.
//-----------------------------------------------------------------------------
inline uint32_t BitFieldInsert(uint32_t src, uint32_t insert, uint32_t offset, uint32_t bits)
{
    uint32_t mask = ~(0xffffffff << bits) << offset;
    return (src & ~mask) | (insert << offset);
}

//-----------------------------------------------------------------------------
//      入力のうち低い方の16ビットを1つおきのビットごとに分離する.
//-----------------------------------------------------------------------------
inline uint32_t Part1By1(uint32_t x)
{
    x &= 0x0000ffff;                  // x = ---- ---- ---- ---- fedc ba98 7654 3210
    x = (x ^ (x <<  8)) & 0x00ff00ff; // x = ---- ---- fedc ba98 ---- ---- 7654 3210
    x = (x ^ (x <<  4)) & 0x0f0f0f0f; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
    x = (x ^ (x <<  2)) & 0x33333333; // x = --fe --dc --ba --98 --76 --54 --32 --10
    x = (x ^ (x <<  1)) & 0x55555555; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
    return x;
}

//-----------------------------------------------------------------------------
//      入力のうち低い方の10ビットを2つおきのビットごとに分離する.
//-----------------------------------------------------------------------------
inline uint32_t Part1By2(uint32_t x)
{
    x &= 0x000003ff;                  // x = ---- ---- ---- ---- ---- --98 7654 3210
    x = (x ^ (x << 16)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
    x = (x ^ (x <<  8)) & 0x0300f00f; // x = ---- --98 ---- ---- 7654 ---- ---- 3210
    x = (x ^ (x <<  4)) & 0x030c30c3; // x = ---- --98 ---- 76-- --54 ---- 32-- --10
    x = (x ^ (x <<  2)) & 0x09249249; // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
    return x;
}

//-----------------------------------------------------------------------------
//      1つおきのビットをコンパクションします.
//-----------------------------------------------------------------------------
inline uint32_t Compact1By1(uint32_t x)
{
    x &= 0x55555555;                  // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
    x = (x ^ (x >>  1)) & 0x33333333; // x = --fe --dc --ba --98 --76 --54 --32 --10
    x = (x ^ (x >>  2)) & 0x0f0f0f0f; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
    x = (x ^ (x >>  4)) & 0x00ff00ff; // x = ---- ---- fedc ba98 ---- ---- 7654 3210
    x = (x ^ (x >>  8)) & 0x0000ffff; // x = ---- ---- ---- ---- fedc ba98 7654 3210
    return x;
}

//-----------------------------------------------------------------------------
//      2つおきのビットをコンパクションします.
//-----------------------------------------------------------------------------
inline uint32_t Compact1By2(uint32_t x)
{
    x &= 0x09249249;                  // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
    x = (x ^ (x >>  2)) & 0x030c30c3; // x = ---- --98 ---- 76-- --54 ---- 32-- --10
    x = (x ^ (x >>  4)) & 0x0300f00f; // x = ---- --98 ---- ---- 7654 ---- ---- 3210
    x = (x ^ (x >>  8)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
    x = (x ^ (x >> 16)) & 0x000003ff; // x = ---- ---- ---- ---- ---- --98 7654 3210
    return x;
}

//-----------------------------------------------------------------------------
//      2次元のモートンコードをエンコードします.
//-----------------------------------------------------------------------------
inline uint32_t EncodeMorton2(uint32_t x, uint32_t y)
{ return (Part1By1(y) << 1) | Part1By1(x); }

//-----------------------------------------------------------------------------
//      3次元のモートンコードをエンコードします.
//-----------------------------------------------------------------------------
inline uint32_t EncodeMorton3(uint32_t x, uint32_t y, uint32_t z)
{ return (Part1By2(z) << 2) | (Part1By2(y) << 1) | Part1By2(x); }

//-----------------------------------------------------------------------------
//      2次元のモートンコードをデコードします.
//-----------------------------------------------------------------------------
inline void DecodeMorton2(uint32_t code, uint32_t& x, uint32_t& y)
{
    x = Compact1By1(code >> 0);
    y = Compact1By1(code >> 1);
}

//-----------------------------------------------------------------------------
//      3次元のモートンコードをデコードします.
//-----------------------------------------------------------------------------
inline void DecodeMorton3(uint32_t code, uint32_t& x, uint32_t& y, uint32_t z)
{
    x = Compact1By2(code >> 0);
    y = Compact1By2(code >> 1);
    z = Compact1By2(code >> 2);
}

///////////////////////////////////////////////////////////////////////////////
// BitFlags class.
///////////////////////////////////////////////////////////////////////////////
template<typename T>
class BitFlag
{
    //=========================================================================
    // list of friend classes.
    //=========================================================================
    /* NOTHING */

public:
    //=========================================================================
    // public variables.
    //=========================================================================
    /* NOTHING */

    //=========================================================================
    // public methods.
    //=========================================================================

    //-------------------------------------------------------------------------
    //! @brief      コンストラクタです.
    //-------------------------------------------------------------------------
    BitFlag() = default;

    //-------------------------------------------------------------------------
    //! @brief      デストラクタです.
    //-------------------------------------------------------------------------
    ~BitFlag() = default;

    //-------------------------------------------------------------------------
    //! @brief      引数付きコンストラクタです.
    //! 
    //! @param[in]      value       初期値.
    //-------------------------------------------------------------------------
    BitFlag(T value)
    : m_Flags(value)
    { /* DO_NOTHING */ }

    //-------------------------------------------------------------------------
    //! @brief      フラグを設定します.
    //! 
    //! @param[in]      index       インデックス.
    //! @param[in]      value       設定する値.
    //-------------------------------------------------------------------------
    void Set(size_t index, bool value)
    {
        assert(index < sizeof(T) * 8);
        auto bit = T(0x1 << index);
        if (value)
        { m_Flags |= bit; }
        else
        { m_Flags &= ~bit; }
    }

    //-------------------------------------------------------------------------
    //! @brief      フラグを取得します.
    //! 
    //! @param[in]      index       インデックス.
    //! @return     フラグを返却します.
    //-------------------------------------------------------------------------
    bool Get(size_t index) const
    {
        assert(index < sizeof(T) * 8);
        auto bit = T(0x1 << index);
        return !!(m_Flags & bit);
    }

    //-------------------------------------------------------------------------
    //! @brief      フラグをリセットします.
    //-------------------------------------------------------------------------
    void Reset()
    { m_Flags = 0; }

    //-------------------------------------------------------------------------
    //! @brief      マスク結果を取得します.
    //! 
    //! @param[in]      mask        マスクビット.
    //! @return     マスク結果を返却します.
    //-------------------------------------------------------------------------
    T Mask(T mask) const
    { return m_Flags & mask; }

    //-------------------------------------------------------------------------
    //! @brief      任意のフラグが立っているかどうかチェックします.
    //! 
    //! @return     いずれかのフラグが立っていれば true を返却します.
    //-------------------------------------------------------------------------
    bool Any() const
    { return m_Flags != 0; }

    //-------------------------------------------------------------------------
    //! @brief      全てのフラグが立っているかどうかチェックします.
    //! 
    //! @return     全てのフラグが立っていれば true を返却します.
    //-------------------------------------------------------------------------
    bool All() const
    { return m_Flags == T(-1); }

    //-------------------------------------------------------------------------
    //! @brief      全てのビットが0になっているか判定します.
    //! 
    //! @return     全てのビットが0であれば true を返却します.
    //-------------------------------------------------------------------------
    bool None() const
    { return m_Flags == 0; }

    //-------------------------------------------------------------------------
    //! @brief      キャスト演算子です.
    //-------------------------------------------------------------------------
    operator T () const
    { return m_Flags; }

    //-------------------------------------------------------------------------
    //! @brief      使用していないインデックスを取得します.
    //! 
    //! @return     使用していないインデックスを返却します.
    //-------------------------------------------------------------------------
    int FindUnused() const 
    { return FindZeroL(m_Flags); }

private:
    T m_Flags = {};
};

using BitFlag8  = BitFlag<uint8_t>;
using BitFlag16 = BitFlag<uint16_t>;
using BitFlag32 = BitFlag<uint32_t>;
using BitFlag64 = BitFlag<uint64_t>;

} // namespace asf
